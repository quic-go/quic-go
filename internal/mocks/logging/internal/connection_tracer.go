// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/quic-go/quic-go/internal/mocks/logging (interfaces: ConnectionTracer)
//
// Generated by this command:
//
//	mockgen -typed -build_flags=-tags=gomock -package internal -destination internal/connection_tracer.go github.com/quic-go/quic-go/internal/mocks/logging ConnectionTracer
//
// Package internal is a generated GoMock package.
package internal

import (
	net "net"
	reflect "reflect"
	time "time"

	protocol "github.com/quic-go/quic-go/internal/protocol"
	utils "github.com/quic-go/quic-go/internal/utils"
	wire "github.com/quic-go/quic-go/internal/wire"
	logging "github.com/quic-go/quic-go/logging"
	gomock "go.uber.org/mock/gomock"
)

// MockConnectionTracer is a mock of ConnectionTracer interface.
type MockConnectionTracer struct {
	ctrl     *gomock.Controller
	recorder *MockConnectionTracerMockRecorder
}

// MockConnectionTracerMockRecorder is the mock recorder for MockConnectionTracer.
type MockConnectionTracerMockRecorder struct {
	mock *MockConnectionTracer
}

// NewMockConnectionTracer creates a new mock instance.
func NewMockConnectionTracer(ctrl *gomock.Controller) *MockConnectionTracer {
	mock := &MockConnectionTracer{ctrl: ctrl}
	mock.recorder = &MockConnectionTracerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConnectionTracer) EXPECT() *MockConnectionTracerMockRecorder {
	return m.recorder
}

// AcknowledgedPacket mocks base method.
func (m *MockConnectionTracer) AcknowledgedPacket(arg0 protocol.EncryptionLevel, arg1 protocol.PacketNumber) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AcknowledgedPacket", arg0, arg1)
}

// AcknowledgedPacket indicates an expected call of AcknowledgedPacket.
func (mr *MockConnectionTracerMockRecorder) AcknowledgedPacket(arg0, arg1 any) *ConnectionTracerAcknowledgedPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AcknowledgedPacket", reflect.TypeOf((*MockConnectionTracer)(nil).AcknowledgedPacket), arg0, arg1)
	return &ConnectionTracerAcknowledgedPacketCall{Call: call}
}

// ConnectionTracerAcknowledgedPacketCall wrap *gomock.Call
type ConnectionTracerAcknowledgedPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerAcknowledgedPacketCall) Return() *ConnectionTracerAcknowledgedPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerAcknowledgedPacketCall) Do(f func(protocol.EncryptionLevel, protocol.PacketNumber)) *ConnectionTracerAcknowledgedPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerAcknowledgedPacketCall) DoAndReturn(f func(protocol.EncryptionLevel, protocol.PacketNumber)) *ConnectionTracerAcknowledgedPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BufferedPacket mocks base method.
func (m *MockConnectionTracer) BufferedPacket(arg0 logging.PacketType, arg1 protocol.ByteCount) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "BufferedPacket", arg0, arg1)
}

// BufferedPacket indicates an expected call of BufferedPacket.
func (mr *MockConnectionTracerMockRecorder) BufferedPacket(arg0, arg1 any) *ConnectionTracerBufferedPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BufferedPacket", reflect.TypeOf((*MockConnectionTracer)(nil).BufferedPacket), arg0, arg1)
	return &ConnectionTracerBufferedPacketCall{Call: call}
}

// ConnectionTracerBufferedPacketCall wrap *gomock.Call
type ConnectionTracerBufferedPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerBufferedPacketCall) Return() *ConnectionTracerBufferedPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerBufferedPacketCall) Do(f func(logging.PacketType, protocol.ByteCount)) *ConnectionTracerBufferedPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerBufferedPacketCall) DoAndReturn(f func(logging.PacketType, protocol.ByteCount)) *ConnectionTracerBufferedPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockConnectionTracer) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockConnectionTracerMockRecorder) Close() *ConnectionTracerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConnectionTracer)(nil).Close))
	return &ConnectionTracerCloseCall{Call: call}
}

// ConnectionTracerCloseCall wrap *gomock.Call
type ConnectionTracerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerCloseCall) Return() *ConnectionTracerCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerCloseCall) Do(f func()) *ConnectionTracerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerCloseCall) DoAndReturn(f func()) *ConnectionTracerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClosedConnection mocks base method.
func (m *MockConnectionTracer) ClosedConnection(arg0 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ClosedConnection", arg0)
}

// ClosedConnection indicates an expected call of ClosedConnection.
func (mr *MockConnectionTracerMockRecorder) ClosedConnection(arg0 any) *ConnectionTracerClosedConnectionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClosedConnection", reflect.TypeOf((*MockConnectionTracer)(nil).ClosedConnection), arg0)
	return &ConnectionTracerClosedConnectionCall{Call: call}
}

// ConnectionTracerClosedConnectionCall wrap *gomock.Call
type ConnectionTracerClosedConnectionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerClosedConnectionCall) Return() *ConnectionTracerClosedConnectionCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerClosedConnectionCall) Do(f func(error)) *ConnectionTracerClosedConnectionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerClosedConnectionCall) DoAndReturn(f func(error)) *ConnectionTracerClosedConnectionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Debug mocks base method.
func (m *MockConnectionTracer) Debug(arg0, arg1 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Debug", arg0, arg1)
}

// Debug indicates an expected call of Debug.
func (mr *MockConnectionTracerMockRecorder) Debug(arg0, arg1 any) *ConnectionTracerDebugCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockConnectionTracer)(nil).Debug), arg0, arg1)
	return &ConnectionTracerDebugCall{Call: call}
}

// ConnectionTracerDebugCall wrap *gomock.Call
type ConnectionTracerDebugCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerDebugCall) Return() *ConnectionTracerDebugCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerDebugCall) Do(f func(string, string)) *ConnectionTracerDebugCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerDebugCall) DoAndReturn(f func(string, string)) *ConnectionTracerDebugCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DroppedEncryptionLevel mocks base method.
func (m *MockConnectionTracer) DroppedEncryptionLevel(arg0 protocol.EncryptionLevel) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "DroppedEncryptionLevel", arg0)
}

// DroppedEncryptionLevel indicates an expected call of DroppedEncryptionLevel.
func (mr *MockConnectionTracerMockRecorder) DroppedEncryptionLevel(arg0 any) *ConnectionTracerDroppedEncryptionLevelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DroppedEncryptionLevel", reflect.TypeOf((*MockConnectionTracer)(nil).DroppedEncryptionLevel), arg0)
	return &ConnectionTracerDroppedEncryptionLevelCall{Call: call}
}

// ConnectionTracerDroppedEncryptionLevelCall wrap *gomock.Call
type ConnectionTracerDroppedEncryptionLevelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerDroppedEncryptionLevelCall) Return() *ConnectionTracerDroppedEncryptionLevelCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerDroppedEncryptionLevelCall) Do(f func(protocol.EncryptionLevel)) *ConnectionTracerDroppedEncryptionLevelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerDroppedEncryptionLevelCall) DoAndReturn(f func(protocol.EncryptionLevel)) *ConnectionTracerDroppedEncryptionLevelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DroppedKey mocks base method.
func (m *MockConnectionTracer) DroppedKey(arg0 protocol.KeyPhase) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "DroppedKey", arg0)
}

// DroppedKey indicates an expected call of DroppedKey.
func (mr *MockConnectionTracerMockRecorder) DroppedKey(arg0 any) *ConnectionTracerDroppedKeyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DroppedKey", reflect.TypeOf((*MockConnectionTracer)(nil).DroppedKey), arg0)
	return &ConnectionTracerDroppedKeyCall{Call: call}
}

// ConnectionTracerDroppedKeyCall wrap *gomock.Call
type ConnectionTracerDroppedKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerDroppedKeyCall) Return() *ConnectionTracerDroppedKeyCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerDroppedKeyCall) Do(f func(protocol.KeyPhase)) *ConnectionTracerDroppedKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerDroppedKeyCall) DoAndReturn(f func(protocol.KeyPhase)) *ConnectionTracerDroppedKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DroppedPacket mocks base method.
func (m *MockConnectionTracer) DroppedPacket(arg0 logging.PacketType, arg1 protocol.ByteCount, arg2 logging.PacketDropReason) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "DroppedPacket", arg0, arg1, arg2)
}

// DroppedPacket indicates an expected call of DroppedPacket.
func (mr *MockConnectionTracerMockRecorder) DroppedPacket(arg0, arg1, arg2 any) *ConnectionTracerDroppedPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DroppedPacket", reflect.TypeOf((*MockConnectionTracer)(nil).DroppedPacket), arg0, arg1, arg2)
	return &ConnectionTracerDroppedPacketCall{Call: call}
}

// ConnectionTracerDroppedPacketCall wrap *gomock.Call
type ConnectionTracerDroppedPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerDroppedPacketCall) Return() *ConnectionTracerDroppedPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerDroppedPacketCall) Do(f func(logging.PacketType, protocol.ByteCount, logging.PacketDropReason)) *ConnectionTracerDroppedPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerDroppedPacketCall) DoAndReturn(f func(logging.PacketType, protocol.ByteCount, logging.PacketDropReason)) *ConnectionTracerDroppedPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ECNStateUpdated mocks base method.
func (m *MockConnectionTracer) ECNStateUpdated(arg0 logging.ECNState, arg1 logging.ECNStateTrigger) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ECNStateUpdated", arg0, arg1)
}

// ECNStateUpdated indicates an expected call of ECNStateUpdated.
func (mr *MockConnectionTracerMockRecorder) ECNStateUpdated(arg0, arg1 any) *ConnectionTracerECNStateUpdatedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ECNStateUpdated", reflect.TypeOf((*MockConnectionTracer)(nil).ECNStateUpdated), arg0, arg1)
	return &ConnectionTracerECNStateUpdatedCall{Call: call}
}

// ConnectionTracerECNStateUpdatedCall wrap *gomock.Call
type ConnectionTracerECNStateUpdatedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerECNStateUpdatedCall) Return() *ConnectionTracerECNStateUpdatedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerECNStateUpdatedCall) Do(f func(logging.ECNState, logging.ECNStateTrigger)) *ConnectionTracerECNStateUpdatedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerECNStateUpdatedCall) DoAndReturn(f func(logging.ECNState, logging.ECNStateTrigger)) *ConnectionTracerECNStateUpdatedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LossTimerCanceled mocks base method.
func (m *MockConnectionTracer) LossTimerCanceled() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "LossTimerCanceled")
}

// LossTimerCanceled indicates an expected call of LossTimerCanceled.
func (mr *MockConnectionTracerMockRecorder) LossTimerCanceled() *ConnectionTracerLossTimerCanceledCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LossTimerCanceled", reflect.TypeOf((*MockConnectionTracer)(nil).LossTimerCanceled))
	return &ConnectionTracerLossTimerCanceledCall{Call: call}
}

// ConnectionTracerLossTimerCanceledCall wrap *gomock.Call
type ConnectionTracerLossTimerCanceledCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerLossTimerCanceledCall) Return() *ConnectionTracerLossTimerCanceledCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerLossTimerCanceledCall) Do(f func()) *ConnectionTracerLossTimerCanceledCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerLossTimerCanceledCall) DoAndReturn(f func()) *ConnectionTracerLossTimerCanceledCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LossTimerExpired mocks base method.
func (m *MockConnectionTracer) LossTimerExpired(arg0 logging.TimerType, arg1 protocol.EncryptionLevel) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "LossTimerExpired", arg0, arg1)
}

// LossTimerExpired indicates an expected call of LossTimerExpired.
func (mr *MockConnectionTracerMockRecorder) LossTimerExpired(arg0, arg1 any) *ConnectionTracerLossTimerExpiredCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LossTimerExpired", reflect.TypeOf((*MockConnectionTracer)(nil).LossTimerExpired), arg0, arg1)
	return &ConnectionTracerLossTimerExpiredCall{Call: call}
}

// ConnectionTracerLossTimerExpiredCall wrap *gomock.Call
type ConnectionTracerLossTimerExpiredCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerLossTimerExpiredCall) Return() *ConnectionTracerLossTimerExpiredCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerLossTimerExpiredCall) Do(f func(logging.TimerType, protocol.EncryptionLevel)) *ConnectionTracerLossTimerExpiredCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerLossTimerExpiredCall) DoAndReturn(f func(logging.TimerType, protocol.EncryptionLevel)) *ConnectionTracerLossTimerExpiredCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LostPacket mocks base method.
func (m *MockConnectionTracer) LostPacket(arg0 protocol.EncryptionLevel, arg1 protocol.PacketNumber, arg2 logging.PacketLossReason) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "LostPacket", arg0, arg1, arg2)
}

// LostPacket indicates an expected call of LostPacket.
func (mr *MockConnectionTracerMockRecorder) LostPacket(arg0, arg1, arg2 any) *ConnectionTracerLostPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LostPacket", reflect.TypeOf((*MockConnectionTracer)(nil).LostPacket), arg0, arg1, arg2)
	return &ConnectionTracerLostPacketCall{Call: call}
}

// ConnectionTracerLostPacketCall wrap *gomock.Call
type ConnectionTracerLostPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerLostPacketCall) Return() *ConnectionTracerLostPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerLostPacketCall) Do(f func(protocol.EncryptionLevel, protocol.PacketNumber, logging.PacketLossReason)) *ConnectionTracerLostPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerLostPacketCall) DoAndReturn(f func(protocol.EncryptionLevel, protocol.PacketNumber, logging.PacketLossReason)) *ConnectionTracerLostPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NegotiatedVersion mocks base method.
func (m *MockConnectionTracer) NegotiatedVersion(arg0 protocol.VersionNumber, arg1, arg2 []protocol.VersionNumber) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "NegotiatedVersion", arg0, arg1, arg2)
}

// NegotiatedVersion indicates an expected call of NegotiatedVersion.
func (mr *MockConnectionTracerMockRecorder) NegotiatedVersion(arg0, arg1, arg2 any) *ConnectionTracerNegotiatedVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NegotiatedVersion", reflect.TypeOf((*MockConnectionTracer)(nil).NegotiatedVersion), arg0, arg1, arg2)
	return &ConnectionTracerNegotiatedVersionCall{Call: call}
}

// ConnectionTracerNegotiatedVersionCall wrap *gomock.Call
type ConnectionTracerNegotiatedVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerNegotiatedVersionCall) Return() *ConnectionTracerNegotiatedVersionCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerNegotiatedVersionCall) Do(f func(protocol.VersionNumber, []protocol.VersionNumber, []protocol.VersionNumber)) *ConnectionTracerNegotiatedVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerNegotiatedVersionCall) DoAndReturn(f func(protocol.VersionNumber, []protocol.VersionNumber, []protocol.VersionNumber)) *ConnectionTracerNegotiatedVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReceivedLongHeaderPacket mocks base method.
func (m *MockConnectionTracer) ReceivedLongHeaderPacket(arg0 *wire.ExtendedHeader, arg1 protocol.ByteCount, arg2 protocol.ECN, arg3 []logging.Frame) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReceivedLongHeaderPacket", arg0, arg1, arg2, arg3)
}

// ReceivedLongHeaderPacket indicates an expected call of ReceivedLongHeaderPacket.
func (mr *MockConnectionTracerMockRecorder) ReceivedLongHeaderPacket(arg0, arg1, arg2, arg3 any) *ConnectionTracerReceivedLongHeaderPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceivedLongHeaderPacket", reflect.TypeOf((*MockConnectionTracer)(nil).ReceivedLongHeaderPacket), arg0, arg1, arg2, arg3)
	return &ConnectionTracerReceivedLongHeaderPacketCall{Call: call}
}

// ConnectionTracerReceivedLongHeaderPacketCall wrap *gomock.Call
type ConnectionTracerReceivedLongHeaderPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerReceivedLongHeaderPacketCall) Return() *ConnectionTracerReceivedLongHeaderPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerReceivedLongHeaderPacketCall) Do(f func(*wire.ExtendedHeader, protocol.ByteCount, protocol.ECN, []logging.Frame)) *ConnectionTracerReceivedLongHeaderPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerReceivedLongHeaderPacketCall) DoAndReturn(f func(*wire.ExtendedHeader, protocol.ByteCount, protocol.ECN, []logging.Frame)) *ConnectionTracerReceivedLongHeaderPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReceivedRetry mocks base method.
func (m *MockConnectionTracer) ReceivedRetry(arg0 *wire.Header) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReceivedRetry", arg0)
}

// ReceivedRetry indicates an expected call of ReceivedRetry.
func (mr *MockConnectionTracerMockRecorder) ReceivedRetry(arg0 any) *ConnectionTracerReceivedRetryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceivedRetry", reflect.TypeOf((*MockConnectionTracer)(nil).ReceivedRetry), arg0)
	return &ConnectionTracerReceivedRetryCall{Call: call}
}

// ConnectionTracerReceivedRetryCall wrap *gomock.Call
type ConnectionTracerReceivedRetryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerReceivedRetryCall) Return() *ConnectionTracerReceivedRetryCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerReceivedRetryCall) Do(f func(*wire.Header)) *ConnectionTracerReceivedRetryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerReceivedRetryCall) DoAndReturn(f func(*wire.Header)) *ConnectionTracerReceivedRetryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReceivedShortHeaderPacket mocks base method.
func (m *MockConnectionTracer) ReceivedShortHeaderPacket(arg0 *logging.ShortHeader, arg1 protocol.ByteCount, arg2 protocol.ECN, arg3 []logging.Frame) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReceivedShortHeaderPacket", arg0, arg1, arg2, arg3)
}

// ReceivedShortHeaderPacket indicates an expected call of ReceivedShortHeaderPacket.
func (mr *MockConnectionTracerMockRecorder) ReceivedShortHeaderPacket(arg0, arg1, arg2, arg3 any) *ConnectionTracerReceivedShortHeaderPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceivedShortHeaderPacket", reflect.TypeOf((*MockConnectionTracer)(nil).ReceivedShortHeaderPacket), arg0, arg1, arg2, arg3)
	return &ConnectionTracerReceivedShortHeaderPacketCall{Call: call}
}

// ConnectionTracerReceivedShortHeaderPacketCall wrap *gomock.Call
type ConnectionTracerReceivedShortHeaderPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerReceivedShortHeaderPacketCall) Return() *ConnectionTracerReceivedShortHeaderPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerReceivedShortHeaderPacketCall) Do(f func(*logging.ShortHeader, protocol.ByteCount, protocol.ECN, []logging.Frame)) *ConnectionTracerReceivedShortHeaderPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerReceivedShortHeaderPacketCall) DoAndReturn(f func(*logging.ShortHeader, protocol.ByteCount, protocol.ECN, []logging.Frame)) *ConnectionTracerReceivedShortHeaderPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReceivedTransportParameters mocks base method.
func (m *MockConnectionTracer) ReceivedTransportParameters(arg0 *wire.TransportParameters) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReceivedTransportParameters", arg0)
}

// ReceivedTransportParameters indicates an expected call of ReceivedTransportParameters.
func (mr *MockConnectionTracerMockRecorder) ReceivedTransportParameters(arg0 any) *ConnectionTracerReceivedTransportParametersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceivedTransportParameters", reflect.TypeOf((*MockConnectionTracer)(nil).ReceivedTransportParameters), arg0)
	return &ConnectionTracerReceivedTransportParametersCall{Call: call}
}

// ConnectionTracerReceivedTransportParametersCall wrap *gomock.Call
type ConnectionTracerReceivedTransportParametersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerReceivedTransportParametersCall) Return() *ConnectionTracerReceivedTransportParametersCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerReceivedTransportParametersCall) Do(f func(*wire.TransportParameters)) *ConnectionTracerReceivedTransportParametersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerReceivedTransportParametersCall) DoAndReturn(f func(*wire.TransportParameters)) *ConnectionTracerReceivedTransportParametersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReceivedVersionNegotiationPacket mocks base method.
func (m *MockConnectionTracer) ReceivedVersionNegotiationPacket(arg0, arg1 protocol.ArbitraryLenConnectionID, arg2 []protocol.VersionNumber) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReceivedVersionNegotiationPacket", arg0, arg1, arg2)
}

// ReceivedVersionNegotiationPacket indicates an expected call of ReceivedVersionNegotiationPacket.
func (mr *MockConnectionTracerMockRecorder) ReceivedVersionNegotiationPacket(arg0, arg1, arg2 any) *ConnectionTracerReceivedVersionNegotiationPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceivedVersionNegotiationPacket", reflect.TypeOf((*MockConnectionTracer)(nil).ReceivedVersionNegotiationPacket), arg0, arg1, arg2)
	return &ConnectionTracerReceivedVersionNegotiationPacketCall{Call: call}
}

// ConnectionTracerReceivedVersionNegotiationPacketCall wrap *gomock.Call
type ConnectionTracerReceivedVersionNegotiationPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerReceivedVersionNegotiationPacketCall) Return() *ConnectionTracerReceivedVersionNegotiationPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerReceivedVersionNegotiationPacketCall) Do(f func(protocol.ArbitraryLenConnectionID, protocol.ArbitraryLenConnectionID, []protocol.VersionNumber)) *ConnectionTracerReceivedVersionNegotiationPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerReceivedVersionNegotiationPacketCall) DoAndReturn(f func(protocol.ArbitraryLenConnectionID, protocol.ArbitraryLenConnectionID, []protocol.VersionNumber)) *ConnectionTracerReceivedVersionNegotiationPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RestoredTransportParameters mocks base method.
func (m *MockConnectionTracer) RestoredTransportParameters(arg0 *wire.TransportParameters) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RestoredTransportParameters", arg0)
}

// RestoredTransportParameters indicates an expected call of RestoredTransportParameters.
func (mr *MockConnectionTracerMockRecorder) RestoredTransportParameters(arg0 any) *ConnectionTracerRestoredTransportParametersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestoredTransportParameters", reflect.TypeOf((*MockConnectionTracer)(nil).RestoredTransportParameters), arg0)
	return &ConnectionTracerRestoredTransportParametersCall{Call: call}
}

// ConnectionTracerRestoredTransportParametersCall wrap *gomock.Call
type ConnectionTracerRestoredTransportParametersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerRestoredTransportParametersCall) Return() *ConnectionTracerRestoredTransportParametersCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerRestoredTransportParametersCall) Do(f func(*wire.TransportParameters)) *ConnectionTracerRestoredTransportParametersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerRestoredTransportParametersCall) DoAndReturn(f func(*wire.TransportParameters)) *ConnectionTracerRestoredTransportParametersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SentLongHeaderPacket mocks base method.
func (m *MockConnectionTracer) SentLongHeaderPacket(arg0 *wire.ExtendedHeader, arg1 protocol.ByteCount, arg2 protocol.ECN, arg3 *wire.AckFrame, arg4 []logging.Frame) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SentLongHeaderPacket", arg0, arg1, arg2, arg3, arg4)
}

// SentLongHeaderPacket indicates an expected call of SentLongHeaderPacket.
func (mr *MockConnectionTracerMockRecorder) SentLongHeaderPacket(arg0, arg1, arg2, arg3, arg4 any) *ConnectionTracerSentLongHeaderPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SentLongHeaderPacket", reflect.TypeOf((*MockConnectionTracer)(nil).SentLongHeaderPacket), arg0, arg1, arg2, arg3, arg4)
	return &ConnectionTracerSentLongHeaderPacketCall{Call: call}
}

// ConnectionTracerSentLongHeaderPacketCall wrap *gomock.Call
type ConnectionTracerSentLongHeaderPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerSentLongHeaderPacketCall) Return() *ConnectionTracerSentLongHeaderPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerSentLongHeaderPacketCall) Do(f func(*wire.ExtendedHeader, protocol.ByteCount, protocol.ECN, *wire.AckFrame, []logging.Frame)) *ConnectionTracerSentLongHeaderPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerSentLongHeaderPacketCall) DoAndReturn(f func(*wire.ExtendedHeader, protocol.ByteCount, protocol.ECN, *wire.AckFrame, []logging.Frame)) *ConnectionTracerSentLongHeaderPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SentShortHeaderPacket mocks base method.
func (m *MockConnectionTracer) SentShortHeaderPacket(arg0 *logging.ShortHeader, arg1 protocol.ByteCount, arg2 protocol.ECN, arg3 *wire.AckFrame, arg4 []logging.Frame) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SentShortHeaderPacket", arg0, arg1, arg2, arg3, arg4)
}

// SentShortHeaderPacket indicates an expected call of SentShortHeaderPacket.
func (mr *MockConnectionTracerMockRecorder) SentShortHeaderPacket(arg0, arg1, arg2, arg3, arg4 any) *ConnectionTracerSentShortHeaderPacketCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SentShortHeaderPacket", reflect.TypeOf((*MockConnectionTracer)(nil).SentShortHeaderPacket), arg0, arg1, arg2, arg3, arg4)
	return &ConnectionTracerSentShortHeaderPacketCall{Call: call}
}

// ConnectionTracerSentShortHeaderPacketCall wrap *gomock.Call
type ConnectionTracerSentShortHeaderPacketCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerSentShortHeaderPacketCall) Return() *ConnectionTracerSentShortHeaderPacketCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerSentShortHeaderPacketCall) Do(f func(*logging.ShortHeader, protocol.ByteCount, protocol.ECN, *wire.AckFrame, []logging.Frame)) *ConnectionTracerSentShortHeaderPacketCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerSentShortHeaderPacketCall) DoAndReturn(f func(*logging.ShortHeader, protocol.ByteCount, protocol.ECN, *wire.AckFrame, []logging.Frame)) *ConnectionTracerSentShortHeaderPacketCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SentTransportParameters mocks base method.
func (m *MockConnectionTracer) SentTransportParameters(arg0 *wire.TransportParameters) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SentTransportParameters", arg0)
}

// SentTransportParameters indicates an expected call of SentTransportParameters.
func (mr *MockConnectionTracerMockRecorder) SentTransportParameters(arg0 any) *ConnectionTracerSentTransportParametersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SentTransportParameters", reflect.TypeOf((*MockConnectionTracer)(nil).SentTransportParameters), arg0)
	return &ConnectionTracerSentTransportParametersCall{Call: call}
}

// ConnectionTracerSentTransportParametersCall wrap *gomock.Call
type ConnectionTracerSentTransportParametersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerSentTransportParametersCall) Return() *ConnectionTracerSentTransportParametersCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerSentTransportParametersCall) Do(f func(*wire.TransportParameters)) *ConnectionTracerSentTransportParametersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerSentTransportParametersCall) DoAndReturn(f func(*wire.TransportParameters)) *ConnectionTracerSentTransportParametersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetLossTimer mocks base method.
func (m *MockConnectionTracer) SetLossTimer(arg0 logging.TimerType, arg1 protocol.EncryptionLevel, arg2 time.Time) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetLossTimer", arg0, arg1, arg2)
}

// SetLossTimer indicates an expected call of SetLossTimer.
func (mr *MockConnectionTracerMockRecorder) SetLossTimer(arg0, arg1, arg2 any) *ConnectionTracerSetLossTimerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLossTimer", reflect.TypeOf((*MockConnectionTracer)(nil).SetLossTimer), arg0, arg1, arg2)
	return &ConnectionTracerSetLossTimerCall{Call: call}
}

// ConnectionTracerSetLossTimerCall wrap *gomock.Call
type ConnectionTracerSetLossTimerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerSetLossTimerCall) Return() *ConnectionTracerSetLossTimerCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerSetLossTimerCall) Do(f func(logging.TimerType, protocol.EncryptionLevel, time.Time)) *ConnectionTracerSetLossTimerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerSetLossTimerCall) DoAndReturn(f func(logging.TimerType, protocol.EncryptionLevel, time.Time)) *ConnectionTracerSetLossTimerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartedConnection mocks base method.
func (m *MockConnectionTracer) StartedConnection(arg0, arg1 net.Addr, arg2, arg3 protocol.ConnectionID) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StartedConnection", arg0, arg1, arg2, arg3)
}

// StartedConnection indicates an expected call of StartedConnection.
func (mr *MockConnectionTracerMockRecorder) StartedConnection(arg0, arg1, arg2, arg3 any) *ConnectionTracerStartedConnectionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartedConnection", reflect.TypeOf((*MockConnectionTracer)(nil).StartedConnection), arg0, arg1, arg2, arg3)
	return &ConnectionTracerStartedConnectionCall{Call: call}
}

// ConnectionTracerStartedConnectionCall wrap *gomock.Call
type ConnectionTracerStartedConnectionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerStartedConnectionCall) Return() *ConnectionTracerStartedConnectionCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerStartedConnectionCall) Do(f func(net.Addr, net.Addr, protocol.ConnectionID, protocol.ConnectionID)) *ConnectionTracerStartedConnectionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerStartedConnectionCall) DoAndReturn(f func(net.Addr, net.Addr, protocol.ConnectionID, protocol.ConnectionID)) *ConnectionTracerStartedConnectionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdatedCongestionState mocks base method.
func (m *MockConnectionTracer) UpdatedCongestionState(arg0 logging.CongestionState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdatedCongestionState", arg0)
}

// UpdatedCongestionState indicates an expected call of UpdatedCongestionState.
func (mr *MockConnectionTracerMockRecorder) UpdatedCongestionState(arg0 any) *ConnectionTracerUpdatedCongestionStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatedCongestionState", reflect.TypeOf((*MockConnectionTracer)(nil).UpdatedCongestionState), arg0)
	return &ConnectionTracerUpdatedCongestionStateCall{Call: call}
}

// ConnectionTracerUpdatedCongestionStateCall wrap *gomock.Call
type ConnectionTracerUpdatedCongestionStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerUpdatedCongestionStateCall) Return() *ConnectionTracerUpdatedCongestionStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerUpdatedCongestionStateCall) Do(f func(logging.CongestionState)) *ConnectionTracerUpdatedCongestionStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerUpdatedCongestionStateCall) DoAndReturn(f func(logging.CongestionState)) *ConnectionTracerUpdatedCongestionStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdatedKey mocks base method.
func (m *MockConnectionTracer) UpdatedKey(arg0 protocol.KeyPhase, arg1 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdatedKey", arg0, arg1)
}

// UpdatedKey indicates an expected call of UpdatedKey.
func (mr *MockConnectionTracerMockRecorder) UpdatedKey(arg0, arg1 any) *ConnectionTracerUpdatedKeyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatedKey", reflect.TypeOf((*MockConnectionTracer)(nil).UpdatedKey), arg0, arg1)
	return &ConnectionTracerUpdatedKeyCall{Call: call}
}

// ConnectionTracerUpdatedKeyCall wrap *gomock.Call
type ConnectionTracerUpdatedKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerUpdatedKeyCall) Return() *ConnectionTracerUpdatedKeyCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerUpdatedKeyCall) Do(f func(protocol.KeyPhase, bool)) *ConnectionTracerUpdatedKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerUpdatedKeyCall) DoAndReturn(f func(protocol.KeyPhase, bool)) *ConnectionTracerUpdatedKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdatedKeyFromTLS mocks base method.
func (m *MockConnectionTracer) UpdatedKeyFromTLS(arg0 protocol.EncryptionLevel, arg1 protocol.Perspective) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdatedKeyFromTLS", arg0, arg1)
}

// UpdatedKeyFromTLS indicates an expected call of UpdatedKeyFromTLS.
func (mr *MockConnectionTracerMockRecorder) UpdatedKeyFromTLS(arg0, arg1 any) *ConnectionTracerUpdatedKeyFromTLSCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatedKeyFromTLS", reflect.TypeOf((*MockConnectionTracer)(nil).UpdatedKeyFromTLS), arg0, arg1)
	return &ConnectionTracerUpdatedKeyFromTLSCall{Call: call}
}

// ConnectionTracerUpdatedKeyFromTLSCall wrap *gomock.Call
type ConnectionTracerUpdatedKeyFromTLSCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerUpdatedKeyFromTLSCall) Return() *ConnectionTracerUpdatedKeyFromTLSCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerUpdatedKeyFromTLSCall) Do(f func(protocol.EncryptionLevel, protocol.Perspective)) *ConnectionTracerUpdatedKeyFromTLSCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerUpdatedKeyFromTLSCall) DoAndReturn(f func(protocol.EncryptionLevel, protocol.Perspective)) *ConnectionTracerUpdatedKeyFromTLSCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdatedMetrics mocks base method.
func (m *MockConnectionTracer) UpdatedMetrics(arg0 *utils.RTTStats, arg1, arg2 protocol.ByteCount, arg3 int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdatedMetrics", arg0, arg1, arg2, arg3)
}

// UpdatedMetrics indicates an expected call of UpdatedMetrics.
func (mr *MockConnectionTracerMockRecorder) UpdatedMetrics(arg0, arg1, arg2, arg3 any) *ConnectionTracerUpdatedMetricsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatedMetrics", reflect.TypeOf((*MockConnectionTracer)(nil).UpdatedMetrics), arg0, arg1, arg2, arg3)
	return &ConnectionTracerUpdatedMetricsCall{Call: call}
}

// ConnectionTracerUpdatedMetricsCall wrap *gomock.Call
type ConnectionTracerUpdatedMetricsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerUpdatedMetricsCall) Return() *ConnectionTracerUpdatedMetricsCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerUpdatedMetricsCall) Do(f func(*utils.RTTStats, protocol.ByteCount, protocol.ByteCount, int)) *ConnectionTracerUpdatedMetricsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerUpdatedMetricsCall) DoAndReturn(f func(*utils.RTTStats, protocol.ByteCount, protocol.ByteCount, int)) *ConnectionTracerUpdatedMetricsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdatedPTOCount mocks base method.
func (m *MockConnectionTracer) UpdatedPTOCount(arg0 uint32) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdatedPTOCount", arg0)
}

// UpdatedPTOCount indicates an expected call of UpdatedPTOCount.
func (mr *MockConnectionTracerMockRecorder) UpdatedPTOCount(arg0 any) *ConnectionTracerUpdatedPTOCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatedPTOCount", reflect.TypeOf((*MockConnectionTracer)(nil).UpdatedPTOCount), arg0)
	return &ConnectionTracerUpdatedPTOCountCall{Call: call}
}

// ConnectionTracerUpdatedPTOCountCall wrap *gomock.Call
type ConnectionTracerUpdatedPTOCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectionTracerUpdatedPTOCountCall) Return() *ConnectionTracerUpdatedPTOCountCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectionTracerUpdatedPTOCountCall) Do(f func(uint32)) *ConnectionTracerUpdatedPTOCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectionTracerUpdatedPTOCountCall) DoAndReturn(f func(uint32)) *ConnectionTracerUpdatedPTOCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
